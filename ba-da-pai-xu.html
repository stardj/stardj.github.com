<!doctype html>
<html lang="en" itemscope itemtype="http://schema.org/Person">
<head>
  <meta charset="utf-8">
  <!-- Site Meta Data -->
  <title>八大排序</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="stardj">

  <link rel="shortcut icon" href="">

  <!-- schema.org -->
  <meta itemprop="name" content="Stardj is coding">
  <meta itemprop="image" content="">
  <meta itemprop="description" content="">

  <!-- Style Meta Data -->
  <link rel="stylesheet" href="/theme/css/milligram.css" type="text/css" />
  <link rel="stylesheet" href="/theme/css/custom.css" type="text/css" />

  <!-- Feed Meta Data -->

  <!-- Twitter Feed -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="">
  <meta name="twitter:image" content="">

<meta name="twitter:creator" content="">
<meta name="twitter:url" content="/ba-da-pai-xu.html">
<meta name="twitter:title" content="Stardj is coding ~ 八大排序">
<meta name="twitter:description" content="八大排序(Java实现) 冒泡排序 算法描述：冒泡排序是一种交换排序，主要思想就是比较相邻元素，然后将较小的元素交换到前面，较大的元素交换到后面。 时间复杂度：O(N^2) 稳定性描述：由于交换是逐个进行的，且相等的元素不进行交换，所以冒泡法排序是一种稳定排序算法。 public class BubbleSort { public static void bubbleSort(int[] n){ for(int i = 0;i&lt;n.length;i++){ for(int j = 0;j&lt;n.length-i-1;j++){ if(n[j]&gt;n[j+1]){ n …">

<!-- Facebook Meta Data -->
<meta property="og:title" content="Stardj is coding ~ 八大排序" />
<meta property="og:description" content="八大排序(Java实现) 冒泡排序 算法描述：冒泡排序是一种交换排序，主要思想就是比较相邻元素，然后将较小的元素交换到前面，较大的元素交换到后面。 时间复杂度：O(N^2) 稳定性描述：由于交换是逐个进行的，且相等的元素不进行交换，所以冒泡法排序是一种稳定排序算法。 public class BubbleSort { public static void bubbleSort(int[] n){ for(int i = 0;i&lt;n.length;i++){ for(int j = 0;j&lt;n.length-i-1;j++){ if(n[j]&gt;n[j+1]){ n …" />
<meta property="og:image" content="" />
</head>

<body>
    <div class="container">

    <!-- Navbar -->
      <div class="navbar">
        <ul>
            <div>
                <li>
                    <a href=""><h3>Stardj is coding</h3></a>
                </li>
                <li>
                </li>
            </div>
        </ul>
      </div>

  <!-- Sidebar -->
    <sidebar>
        <ul class="static-item">

        </ul>        

        <ul>
                <div class="cat-border">
                <li style="color: #F2F1EF; background-color: #6C7A89;">Categories</li>
                    <li><a href="/category/algorithm.html">Algorithm</a></li>
                    <li><a href="/category/ielts.html">IELTS</a></li>
                    <li><a href="/category/machine-learning.html">Machine Learning</a></li>
                    <li><a href="/category/uncategorized.html">Uncategorized</a></li>
                </div>
        </ul>

            <h2><br/>BLOGROLLS</h2>
            <ul>
                    <li><a href="http://getpelican.com/">Pelican</a></li>
                    <li><a href="http://python.org/">Python.org</a></li>
                    <li><a href="http://jinja.pocoo.org/">Jinja2</a></li>
                    <li><a href="#">You can modify those links in your config file</a></li>
            </ul> 
   
        <p> 
                <span>
                    <a href="#" target="_blank">
                        <img class="social-icons-m" src="/theme/images/icons/you can add links in your config file.png">
                    </a>
                </span>
                <span>
                    <a href="#" target="_blank">
                        <img class="social-icons-m" src="/theme/images/icons/another social link.png">
                    </a>
                </span>
        </p>
        <p>
        </p>
        <p>
        </p>
    </sidebar>
    
    <maincontent>
<h2>
    <a href="/ba-da-pai-xu.html" rel="bookmark" title="Permalink to 八大排序">八大排序</a>
</h2>

<div>
    <b>By: </b><a href="/author/stardj.html">stardj</a><b>    On: </b>Tue 10 November 2015<br />
    <b>In: </b><a href="/category/algorithm.html" rel="bookmark" title="Permalink to Algorithm">Algorithm</a><br />
    <em><b>Tags: </b>
                <span><a href="/tag/pai-xu.html">#排序 </a></span>
    </em>
    <hr>
</div>

<div>
    <mainarticle>
    <h4>八大排序(Java实现)</h4>
<ul>
<li>冒泡排序</li>
</ul>
<p>算法描述：冒泡排序是一种交换排序，主要思想就是比较相邻元素，然后将较小的元素交换到前面，较大的元素交换到后面。</p>
<p>时间复杂度：O(N^2)</p>
<p>稳定性描述：由于交换是逐个进行的，且相等的元素不进行交换，所以冒泡法排序是一种稳定排序算法。</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BubbleSort</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">bubbleSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">n</span><span class="o">){</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">[</span><span class="n">j</span><span class="o">]&gt;</span><span class="n">n</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]){</span>
                    <span class="n">n</span><span class="o">[</span><span class="n">j</span><span class="o">]^=</span><span class="n">n</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
                    <span class="n">n</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]^=</span><span class="n">n</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                    <span class="n">n</span><span class="o">[</span><span class="n">j</span><span class="o">]^=</span><span class="n">n</span><span class="o">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>直接选择排序</li>
</ul>
<p>算法描述：直接选择排序是一种选择排序，主要思想是在给定序列中选择最小的元素，与序列中第1个元素进行交换，然后在余下的元素中选择总序列中第2小的，与序列中第2个元素进行交换，以此类推，不断选择出第i小的元素与总序列第i位元素交换，直到选到最后一个最大元素。</p>
<p>时间复杂度：O(N^2)</p>
<p>稳定性描述：这种选择的方法会导致稳定性的问题，例如：序列{4,4,2}，在第一次选择交换后序列变为{2,4,4}，原序列中第一个4就移动到了原序列中第二个4的后面，所以直接选择排序是一种不稳定排序算法。</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SelectSort</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">SelectSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">n</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">min</span> <span class="o">=</span> <span class="n">n</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">n</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">n</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">n</span><span class="o">[</span><span class="n">index</span><span class="o">];</span>
            <span class="n">n</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>直接插入排序</li>
</ul>
<p>算法描述：直接插入排序是一种插入排序，主要思想是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果不比它小则直接插入在其后面，否则一直往前找直到找到它该插入的位置。</p>
<p>时间复杂度：O(N^2) </p>
<p>稳定性描述：如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以直接插入排序是一种稳定的排序算法。</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InsertSort</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">insertSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">j</span><span class="o">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span> <span class="c1">//找到要插入的位置，记做index</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">index</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span> <span class="c1">//插入并移动元素</span>
                <span class="n">n</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">^=</span> <span class="n">n</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
                <span class="n">n</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">^=</span> <span class="n">n</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="n">n</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">^=</span> <span class="n">n</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>
<p>希尔排序</p>
</li>
<li>
<p>快速排序</p>
</li>
</ul>
<p>算法描述：快速排序是一种交换排序，可以看做是冒泡排序的升级版。快速排序会选择一个标兵（一般选择当前子序列的第一个元素或者最后一个元素），然后将小于标兵的元素放置在标兵左边、大于标兵的元素放置在标兵的右边，这样就生成了另外两个子序列，然后进行同样地操作至子序列不可分为止。</p>
<p>时间复杂度为：O(N*log(N))</p>
<p>稳定性描述：因为快速排序在进行交换时会将前面已经经过交换的元素进行打乱，<strong>所以这是一个不稳定排序算法</strong>。</p>
<p>代码实现：</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">QickSort</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">IQickSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">dp</span><span class="o">;</span><span class="c1">//标兵在全序列的位置，即子序列分割点</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">dp</span> <span class="o">=</span> <span class="n">partition</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
            <span class="n">IQickSort</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">dp</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span><span class="c1">//左边子序列递归快排</span>
            <span class="n">IQickSort</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">dp</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span><span class="c1">//右边子序列递归快排</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">partition</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">n</span><span class="o">[</span><span class="n">left</span><span class="o">];</span><span class="c1">//标兵</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>

            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">right</span><span class="o">--;</span>
            <span class="o">}</span><span class="c1">//找出标兵右边比标兵小的元素</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span>
                <span class="n">n</span><span class="o">[</span><span class="n">left</span><span class="o">++]</span> <span class="o">=</span> <span class="n">n</span><span class="o">[</span><span class="n">right</span><span class="o">];</span><span class="c1">//交换</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">left</span><span class="o">++;</span>
            <span class="o">}</span><span class="c1">//找出标兵左边比标兵大的元素</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span>
                <span class="n">n</span><span class="o">[</span><span class="n">right</span><span class="o">--]</span> <span class="o">=</span> <span class="n">n</span><span class="o">[</span><span class="n">left</span><span class="o">];</span><span class="c1">//交换</span>
        <span class="o">}</span>
        <span class="n">n</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">=</span> <span class="n">pivot</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">left</span><span class="o">;</span><span class="c1">//返回标兵最终的位置</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></div>


<ul>
<li>堆排序</li>
</ul>
<p>算法描述：堆排序是一种选择排序，可以看做是直接选择排序的升级版，堆排序是以大顶堆（小顶堆也能实现，这里以大顶堆来进行说明）的性质保持为基础进行选择排序，堆的节点是节点i的孩子（即节点2*i和2*i+1），大顶堆要求父节点大于或等于两个节点。为了维持这个性质，对于一个以i为根的子树A，从元素A[i],A[left(i)],A[right(i)]中选出最大值，如果最大值是根节点则结束，如果是左(右)节点则与根节点进行交换，并对左(右)子树继续进行选择交换，对一个序列构造大顶堆时从第n/2个元素向前进行性质维持就能构造出一个大顶堆。堆排序的思想是选出当前大顶堆的根节点，将其与最后的节点元素进行交换，再移除最后的节点，然后维持大顶堆的性质进行选择交换，直到所有元素移除即完成排序工作。</p>
<p>时间复杂度为：O(N*Log(N))</p>
<p>稳定性描述：堆排序的过程是从第n/2开始和其子节点共3个值选择大顶堆，这3个元素之间的选择当然不会破坏稳定性。但当为(n/2)-1，(n/2)-2 ... 这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第(n/2)-1个父节点把后面一个相同的元素没有交换，那么这2个相同的元素之间的稳定性就被破坏了。<strong>所以，堆排序不是稳定的排序算法</strong>。</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HeapSort</span> <span class="o">{</span>

    <span class="cm">/*交换两个数值*/</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index2</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">n</span><span class="o">[</span><span class="n">index1</span><span class="o">]</span> <span class="o">^=</span> <span class="n">n</span><span class="o">[</span><span class="n">index2</span><span class="o">];</span>
        <span class="n">n</span><span class="o">[</span><span class="n">index2</span><span class="o">]</span> <span class="o">^=</span> <span class="n">n</span><span class="o">[</span><span class="n">index1</span><span class="o">];</span>
        <span class="n">n</span><span class="o">[</span><span class="n">index1</span><span class="o">]</span> <span class="o">^=</span> <span class="n">n</span><span class="o">[</span><span class="n">index2</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">IHeapSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">buildMaxHeapify</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="n">maxHeapify</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/*建立大顶堆*/</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">buildMaxHeapify</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//从第一个非叶子节点开始大顶堆化</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="n">maxHeapify</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/*将树中数值最大的节点交换到根节点*/</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">maxHeapify</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">heapSize</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span><span class="c1">//左叶子节点</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span><span class="c1">//右叶子节点</span>
        <span class="kt">int</span> <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">heapSize</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">[</span><span class="n">largest</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">heapSize</span> <span class="o">&amp;&amp;</span> <span class="n">n</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">[</span><span class="n">largest</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">largest</span> <span class="o">!=</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">n</span><span class="o">,</span><span class="n">i</span><span class="o">,</span><span class="n">largest</span><span class="o">);</span>
            <span class="n">maxHeapify</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">largest</span><span class="o">,</span> <span class="n">heapSize</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></div>


<ul>
<li>归并排序</li>
</ul>
<p>算法描述：归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，合并时采用相互比较两边序列最小值先放入合并序列的方法，然后按顺序不断比较放入合并序列。不断合并直到原序列全部排好序。</p>
<p>时间复杂度：O(N*Log(N))</p>
<p>稳定性描述：可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。<strong>所以，归并排序是稳定的排序算法</strong>。</p>
<div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MergeSort</span> <span class="o">{</span>

    <span class="cm">/*用递归的方法将数组拆分*/</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mergeSort</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
            <span class="n">mergeSort</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
            <span class="n">merge</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/*归并的具体实现*/</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">indexL</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">indexR</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">//将较小的元素插入到temp数组中</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">indexL</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">indexR</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">[</span><span class="n">indexL</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">[</span><span class="n">indexR</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">temp</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">n</span><span class="o">[</span><span class="n">indexL</span><span class="o">++];</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">temp</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">n</span><span class="o">[</span><span class="n">indexR</span><span class="o">++];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">//将还没有插入的元素插入到temp数组中</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">indexL</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">)</span>
            <span class="n">temp</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">n</span><span class="o">[</span><span class="n">indexL</span><span class="o">++];</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">indexR</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span>
            <span class="n">temp</span><span class="o">[</span><span class="n">index</span><span class="o">++]</span> <span class="o">=</span> <span class="n">n</span><span class="o">[</span><span class="n">indexR</span><span class="o">++];</span>

        <span class="c1">//将归并后的数组覆盖到原数组中</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">n</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">left</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>基数排序</li>
</ul>
    </mainarticle>
</div>
<hr>
        
<div>
        <i>If you found the article helpful, please share or cite the article, and spread the word:</i>
            <p style="margin-top: 2%;">
                <span><a target="_blank" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=400,width=700');return false;" title="Twitter" href="https://twitter.com/share?url=/ba-da-pai-xu.html&text=八大排序&via="><img class="social-icons-a" src="/theme/images/icons/twitter.png"></a></span>
                <span><a target="_blank" title="Facebook" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=500,width=700');return false;" href="https://www.facebook.com/sharer.php?u=/ba-da-pai-xu.html&t=八大排序"><img class="social-icons-a" src="/theme/images/icons/facebook.png"></a></span>

                <a  target="_blank" title="Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=/ba-da-pai-xu.html&title=八大排序" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=450,width=650');return false;"><img class="social-icons-a" src="/theme/images/icons/linkedin.png"></a>
            </p>
</div>
<hr>
    <p><i>For any feedback or corrections, please write in to: </i><b> stardj </b></p>
        
    </maincontent>

  <!-- Analytics -->

  </div>
</body>

</html>